/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.4.0 (NJsonSchema v10.3.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class DataProvider {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
      this.http = http ? http : <any>window;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:3000";
  }

  /**
   * The search  GET endpoint
   * @param q The search phrase.
   * @param num The number of results per page.
   * @param start (optional) The number indicating a start index of the result.
   * @param search_in (optional) 
   * @return OK
   */
  getSearchResults(q: string, num: number, start?: number | undefined, search_in?: string[] | undefined): Promise<SearchResultDto> {
      let url_ = this.baseUrl + "/search?";
      if (q === undefined || q === null)
          throw new Error("The parameter 'q' must be defined and cannot be null.");
      else
          url_ += "q=" + encodeURIComponent("" + q) + "&";
      if (num === undefined || num === null)
          throw new Error("The parameter 'num' must be defined and cannot be null.");
      else
          url_ += "num=" + encodeURIComponent("" + num) + "&";
      if (start === null)
          throw new Error("The parameter 'start' cannot be null.");
      else if (start !== undefined)
          url_ += "start=" + encodeURIComponent("" + start) + "&";
      if (search_in === null)
          throw new Error("The parameter 'search_in' cannot be null.");
      else if (search_in !== undefined)
          search_in && search_in.forEach(item => { url_ += "search-in=" + encodeURIComponent("" + item) + "&"; });
      url_ = url_.replace(/[?&]$/, "");

      let options_ = <RequestInit>{
          method: "GET",
          headers: {
              "Accept": "application/json"
          }
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processGetSearchResults(_response);
      });
  }

  protected processGetSearchResults(response: Response): Promise<SearchResultDto> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
      let _mappings: { source: any, target: any }[] = [];
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = SearchResultDto.fromJS(resultData200, _mappings);
          return result200;
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<SearchResultDto>(<any>null);
  }

  /**
   * Your GET endpoint
   * @return OK
   */
  getCourts(): Promise<CourtDto[]> {
      let url_ = this.baseUrl + "/courts";
      url_ = url_.replace(/[?&]$/, "");

      let options_ = <RequestInit>{
          method: "GET",
          headers: {
              "Accept": "application/json"
          }
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processGetCourts(_response);
      });
  }

  protected processGetCourts(response: Response): Promise<CourtDto[]> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
      let _mappings: { source: any, target: any }[] = [];
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
              result200 = [] as any;
              for (let item of resultData200)
                  result200!.push(CourtDto.fromJS(item, _mappings));
          }
          return result200;
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<CourtDto[]>(<any>null);
  }

  /**
   * Gets all of supported court levels.
   * @return OK
   */
  getCourtsLevels(): Promise<CourtLevelDto[]> {
      let url_ = this.baseUrl + "/courts/levels";
      url_ = url_.replace(/[?&]$/, "");

      let options_ = <RequestInit>{
          method: "GET",
          headers: {
              "Accept": "application/json"
          }
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processGetCourtsLevels(_response);
      });
  }

  protected processGetCourtsLevels(response: Response): Promise<CourtLevelDto[]> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
      let _mappings: { source: any, target: any }[] = [];
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
              result200 = [] as any;
              for (let item of resultData200)
                  result200!.push(CourtLevelDto.fromJS(item, _mappings));
          }
          return result200;
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<CourtLevelDto[]>(<any>null);
  }
}

export class SearchResultItemDto {
  fragments!: SearchResultItemFragmentDto[];
  ranks!: RankDto[];
  entities!: EntityDto[];
  relatedCases!: CaseReferenceDto[];
  privilege!: string;
  document!: DocumentReferenceDto;
  mainCase!: CaseReferenceDto;
  filteredWith!: FilterReferenceDto[];

  init(_data?: any, _mappings?: any) {
      if (_data) {
          if (Array.isArray(_data["fragments"])) {
              this.fragments = [] as any;
              for (let item of _data["fragments"])
                  this.fragments!.push(SearchResultItemFragmentDto.fromJS(item, _mappings));
          }
          if (Array.isArray(_data["ranks"])) {
              this.ranks = [] as any;
              for (let item of _data["ranks"])
                  this.ranks!.push(RankDto.fromJS(item, _mappings));
          }
          if (Array.isArray(_data["entities"])) {
              this.entities = [] as any;
              for (let item of _data["entities"])
                  this.entities!.push(EntityDto.fromJS(item, _mappings));
          }
          if (Array.isArray(_data["relatedCases"])) {
              this.relatedCases = [] as any;
              for (let item of _data["relatedCases"])
                  this.relatedCases!.push(CaseReferenceDto.fromJS(item, _mappings));
          }
          this.privilege = _data["privilege"];
          this.document = _data["document"] ? DocumentReferenceDto.fromJS(_data["document"], _mappings) : new DocumentReferenceDto();
          this.mainCase = _data["mainCase"] ? CaseReferenceDto.fromJS(_data["mainCase"], _mappings) : new CaseReferenceDto();
          if (Array.isArray(_data["filteredWith"])) {
              this.filteredWith = [] as any;
              for (let item of _data["filteredWith"])
                  this.filteredWith!.push(FilterReferenceDto.fromJS(item, _mappings));
          }
      }
  }

  static fromJS(data: any, _mappings?: any): SearchResultItemDto {
      data = typeof data === 'object' ? data : {};
      return createInstance<SearchResultItemDto>(data, _mappings, SearchResultItemDto);
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.fragments)) {
          data["fragments"] = [];
          for (let item of this.fragments)
              data["fragments"].push(item.toJSON());
      }
      if (Array.isArray(this.ranks)) {
          data["ranks"] = [];
          for (let item of this.ranks)
              data["ranks"].push(item.toJSON());
      }
      if (Array.isArray(this.entities)) {
          data["entities"] = [];
          for (let item of this.entities)
              data["entities"].push(item.toJSON());
      }
      if (Array.isArray(this.relatedCases)) {
          data["relatedCases"] = [];
          for (let item of this.relatedCases)
              data["relatedCases"].push(item.toJSON());
      }
      data["privilege"] = this.privilege;
      data["document"] = this.document ? this.document.toJSON() : <any>undefined;
      data["mainCase"] = this.mainCase ? this.mainCase.toJSON() : <any>undefined;
      if (Array.isArray(this.filteredWith)) {
          data["filteredWith"] = [];
          for (let item of this.filteredWith)
              data["filteredWith"].push(item.toJSON());
      }
      return data; 
  }
}

export class SearchResultDto {
  items!: SearchResultItemDto[];
  /** The position of the first item returned in whole results array. */
  start!: number;
  /** The position of the last item returned in whole results array. */
  end!: number;
  /** The number of the search result items found. */
  total!: number;
  /** The query execution time. */
  executionTime!: number;

  init(_data?: any, _mappings?: any) {
      if (_data) {
          if (Array.isArray(_data["items"])) {
              this.items = [] as any;
              for (let item of _data["items"])
                  this.items!.push(SearchResultItemDto.fromJS(item, _mappings));
          }
          this.start = _data["start"];
          this.end = _data["end"];
          this.total = _data["total"];
          this.executionTime = _data["executionTime"];
      }
  }

  static fromJS(data: any, _mappings?: any): SearchResultDto {
      data = typeof data === 'object' ? data : {};
      return createInstance<SearchResultDto>(data, _mappings, SearchResultDto);
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
          data["items"] = [];
          for (let item of this.items)
              data["items"].push(item.toJSON());
      }
      data["start"] = this.start;
      data["end"] = this.end;
      data["total"] = this.total;
      data["executionTime"] = this.executionTime;
      return data; 
  }
}

export class SearchResultItemFragmentDto {
  /** Represents a text of the fragment. */
  text!: string;
  highlights!: HighlightedPhraseDto[];

  init(_data?: any, _mappings?: any) {
      if (_data) {
          this.text = _data["text"];
          if (Array.isArray(_data["highlights"])) {
              this.highlights = [] as any;
              for (let item of _data["highlights"])
                  this.highlights!.push(HighlightedPhraseDto.fromJS(item, _mappings));
          }
      }
  }

  static fromJS(data: any, _mappings?: any): SearchResultItemFragmentDto {
      data = typeof data === 'object' ? data : {};
      return createInstance<SearchResultItemFragmentDto>(data, _mappings, SearchResultItemFragmentDto);
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["text"] = this.text;
      if (Array.isArray(this.highlights)) {
          data["highlights"] = [];
          for (let item of this.highlights)
              data["highlights"].push(item.toJSON());
      }
      return data; 
  }
}

/** Represents a highlighted part of the related text. */
export class HighlightedPhraseDto {
  /** The starting position */
  start!: number;
  /** Indicates how many words (tokens) need to highlight */
  count!: number;

  init(_data?: any, _mappings?: any) {
      if (_data) {
          this.start = _data["start"];
          this.count = _data["count"] !== undefined ? _data["count"] : 1;
      }
  }

  static fromJS(data: any, _mappings?: any): HighlightedPhraseDto {
      data = typeof data === 'object' ? data : {};
      return createInstance<HighlightedPhraseDto>(data, _mappings, HighlightedPhraseDto);
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["start"] = this.start;
      data["count"] = this.count;
      return data; 
  }
}

export class RankDto {
  name!: string;
  value!: number;

  init(_data?: any, _mappings?: any) {
      if (_data) {
          this.name = _data["name"];
          this.value = _data["value"];
      }
  }

  static fromJS(data: any, _mappings?: any): RankDto {
      data = typeof data === 'object' ? data : {};
      return createInstance<RankDto>(data, _mappings, RankDto);
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["name"] = this.name;
      data["value"] = this.value;
      return data; 
  }
}

/** Represents the Court DTO. */
export class CourtDto {
  id!: number;
  name!: string;
  level!: string;

  init(_data?: any, _mappings?: any) {
      if (_data) {
          this.id = _data["id"];
          this.name = _data["name"];
          this.level = _data["level"];
      }
  }

  static fromJS(data: any, _mappings?: any): CourtDto {
      data = typeof data === 'object' ? data : {};
      return createInstance<CourtDto>(data, _mappings, CourtDto);
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["name"] = this.name;
      data["level"] = this.level;
      return data; 
  }
}

export class EntityDto {
  value!: string;

  init(_data?: any, _mappings?: any) {
      if (_data) {
          this.value = _data["value"];
      }
  }

  static fromJS(data: any, _mappings?: any): EntityDto {
      data = typeof data === 'object' ? data : {};
      return createInstance<EntityDto>(data, _mappings, EntityDto);
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["value"] = this.value;
      return data; 
  }
}

export class CaseReferenceDto {
  id?: number;

  init(_data?: any, _mappings?: any) {
      if (_data) {
          this.id = _data["id"];
      }
  }

  static fromJS(data: any, _mappings?: any): CaseReferenceDto {
      data = typeof data === 'object' ? data : {};
      return createInstance<CaseReferenceDto>(data, _mappings, CaseReferenceDto);
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      return data; 
  }
}

export class CourtLevelDto {
  id!: number;
  name!: string;

  init(_data?: any, _mappings?: any) {
      if (_data) {
          this.id = _data["id"];
          this.name = _data["name"];
      }
  }

  static fromJS(data: any, _mappings?: any): CourtLevelDto {
      data = typeof data === 'object' ? data : {};
      return createInstance<CourtLevelDto>(data, _mappings, CourtLevelDto);
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["name"] = this.name;
      return data; 
  }
}

export class DocumentReferenceDto {
  id!: number;
  title!: string;

  init(_data?: any, _mappings?: any) {
      if (_data) {
          this.id = _data["id"];
          this.title = _data["title"];
      }
  }

  static fromJS(data: any, _mappings?: any): DocumentReferenceDto {
      data = typeof data === 'object' ? data : {};
      return createInstance<DocumentReferenceDto>(data, _mappings, DocumentReferenceDto);
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["title"] = this.title;
      return data; 
  }
}

export class FilterReferenceDto {
  key!: string;
  value!: string;

  init(_data?: any, _mappings?: any) {
      if (_data) {
          this.key = _data["key"];
          this.value = _data["value"];
      }
  }

  static fromJS(data: any, _mappings?: any): FilterReferenceDto {
      data = typeof data === 'object' ? data : {};
      return createInstance<FilterReferenceDto>(data, _mappings, FilterReferenceDto);
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["key"] = this.key;
      data["value"] = this.value;
      return data; 
  }
}

function jsonParse(json: any, reviver?: any) {
  json = JSON.parse(json, reviver);

  var byid: any = {};
  var refs: any = [];
  json = (function recurse(obj: any, prop?: any, parent?: any) {
      if (typeof obj !== 'object' || !obj)
          return obj;
      
      if ("$ref" in obj) {
          let ref = obj.$ref;
          if (ref in byid)
              return byid[ref];
          refs.push([parent, prop, ref]);
          return undefined;
      } else if ("$id" in obj) {
          let id = obj.$id;
          delete obj.$id;
          if ("$values" in obj)
              obj = obj.$values;
          byid[id] = obj;
      }
      
      if (Array.isArray(obj)) {
          obj = obj.map((v, i) => recurse(v, i, obj));
      } else {
          for (var p in obj) {
              if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                  obj[p] = recurse(obj[p], p, obj);
          }
      }

      return obj;
  })(json);

  for (let i = 0; i < refs.length; i++) {
      const ref = refs[i];
      ref[0][ref[1]] = byid[ref[2]];
  }

  return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T {
if (!mappings)
  mappings = [];
if (!data)
  return null;

const mappingIndexName = "__mappingIndex";
if (data[mappingIndexName])
  return <T>mappings[data[mappingIndexName]].target;

data[mappingIndexName] = mappings.length;

let result: any = new type();
mappings.push({ source: data, target: result });
result.init(data, mappings);
return result;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
      super();

      this.message = message;
      this.status = status;
      this.response = response;
      this.headers = headers;
      this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
      return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
  if (result !== null && result !== undefined)
      throw result;
  else
      throw new ApiException(message, status, response, headers, null);
}
